#!/bin/bash
#
# Заменяет существующее расширение в имени файла на заданное
#
# Примеры:
#    $ extchange hello.txt html
#        hello.txt  -->  hello.html
#    $ extchange ~/myfiles/hello html
#        exit with error
#    $ extchange ~/myfiles/hello.txt html
#        ~/myfiles/hello.txt  -->  ~/myfiles/hello.html
#    $ extchange ~/myfiles/hello.world.txt html
#        ~/myfiles/hello.world.txt  -->  ~/myfiles/hello.world.html
#

# Записываем в переменную `filename` имя файла из первого аргумента нашего скрипта,
# но без пути, то есть `hello.world.html` вместо `~/myfiles/hello.world.html`
filename="${1##*/}" # так же можно сделать с помощью basename - `$(basename -- "$1")`

### Лирическое отступление ###
# В алтернативном варианте с basename можно заметить символы `--`
# в большинстве unix утилит они служат для отедления позиционных аргументов от опций утилиты
# это может быть полезно в случаях, когда опция и аргумент могут совпадать,
# например если не обходимо удалить папку с именем `-r` (да-да это нормльаное имя для папки)
# тогда команда будет `rm -r -- -r`, если про написать `rm -r -r` то утилита выдаст ошибку
### Конец лирического отступления ###

# Проверяем есть ли у файла экстеншин (есть ли точка в имени)
if [[ "$filename" != *.* ]]; then
    echo "File $filename has no extension" >&2 # Сообщение об ошибке перенаправляем в stderr
    exit 1                                     # Выходим с кодом >0, что означет ошибку
fi

# Записываем в переменную `filedir` путь к файлу полученный из первого аргумента нашего скрипта,
# например `~/myfiles/`, если аргумент `~/myfiles/hello.world.html`
# Приходится нагородить целый огород, 
# чтоб корректно обработать случай если файл предан без пути (только имя)
# так как в таком случае `${1%/*}` вернет само имя файли, а не '.' в отличии от `dirname`
filedir="."
[[ $filename = $1 ]] || filedir="${1%/*}"
# Вместе предыдущих двух строк можно было написать одну:
# filedir="$(dirname $1)"


# Записываем в переменную `basename` имя файла без экстеншина
# например `hello.world`, если имя файла `hello.world.html`
basename="${filename%.*}"

# Переименовываем файли

# NB! До этого момента наш скрипт ничего не знает о существании самих файлах
# и работает с их путями, именами исключительно как со строками, т.е. не важно
# существует ли файл и реален ли путь к нему

# Так как мы хотим что бы чтобы наш скрипт работал с путями,
# то надо чтобы оба аргумента `mv` имели полные пути
# например `mv ~/myfiles/hello.txt ~/myfiles/hello.html`
# если в качестве первого аргумента мы может использовать первый аргумента скрипта
# то второй нам надо составить из:
#   $filedir —> ~/myfiles/  (папка с файлом)
#   $basename —> hello.world (имя файла без экстеншина)
#   $2 —> html (новый экстеншин, из второго аргумента нашего скрипта)
mv "$1" "$filedir/$basename.$2"
